"""
消息服务

处理消息的创建、查询等业务逻辑。
"""

from typing import Optional, List, Dict, Any, AsyncIterator

from loguru import logger
from supabase import Client

from core.config import get_settings
from core.exceptions import NotFoundError, PermissionDeniedError, InsufficientCreditsError
from services.conversation_service import ConversationService
from services.adapters.kie.client import KieClient, KieAPIError
from services.adapters.kie.chat_adapter import KieChatAdapter
from services.adapters.kie.models import ReasoningEffort


class MessageService:
    """消息服务类"""

    def __init__(self, db: Client):
        self.db = db
        self.conversation_service = ConversationService(db)

    async def create_message(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        role: str = "user",
        credits_cost: int = 0,
        image_url: Optional[str] = None,
        video_url: Optional[str] = None,
    ) -> dict:
        """
        创建消息

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID（用于权限验证）
            content: 消息内容
            role: 消息角色 (user/assistant/system)
            credits_cost: 消耗积分
            image_url: 图片 URL（可选）
            video_url: 视频 URL（可选）

        Returns:
            消息信息

        Raises:
            NotFoundError: 对话不存在
            PermissionDeniedError: 无权访问
        """
        # 验证对话权限
        await self.conversation_service.get_conversation(conversation_id, user_id)

        message_data = {
            "conversation_id": conversation_id,
            "role": role,
            "content": content,
            "credits_cost": credits_cost,
        }
        if image_url:
            message_data["image_url"] = image_url
        if video_url:
            message_data["video_url"] = video_url

        result = self.db.table("messages").insert(message_data).execute()

        if not result.data:
            logger.error(
                f"Failed to create message | conversation_id={conversation_id}"
            )
            raise Exception("创建消息失败")

        message = result.data[0]

        # 更新对话的消息计数和最后消息预览
        await self.conversation_service.increment_message_count(
            conversation_id, credits_cost
        )
        await self.conversation_service.update_last_message_preview(
            conversation_id, content
        )

        logger.info(
            f"Message created | message_id={message['id']} | "
            f"conversation_id={conversation_id} | role={role}"
        )

        return self._format_message(message)

    async def get_messages(
        self,
        conversation_id: str,
        user_id: str,
        limit: int = 50,
        offset: int = 0,
        before_id: Optional[str] = None,
    ) -> dict:
        """
        获取对话消息列表

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID
            limit: 每页数量
            offset: 偏移量
            before_id: 获取此 ID 之前的消息（用于加载更多）

        Returns:
            消息列表和元数据

        Raises:
            NotFoundError: 对话不存在
            PermissionDeniedError: 无权访问
        """
        # 验证对话权限
        await self.conversation_service.get_conversation(conversation_id, user_id)

        # 构建查询（使用 count="exact" 同时获取消息和总数）
        query = (
            self.db.table("messages")
            .select("*", count="exact")
            .eq("conversation_id", conversation_id)
        )

        if before_id:
            # 获取 before_id 对应消息的创建时间
            before_msg = (
                self.db.table("messages")
                .select("created_at")
                .eq("id", before_id)
                .execute()
            )
            if before_msg.data:
                query = query.lt("created_at", before_msg.data[0]["created_at"])

        # 按创建时间倒序获取
        result = (
            query.order("created_at", desc=True)
            .range(offset, offset + limit - 1)
            .execute()
        )

        # 从合并查询结果中获取总数
        total = result.count or 0
        messages = [self._format_message(msg) for msg in reversed(result.data)]
        has_more = offset + len(result.data) < total

        return {
            "messages": messages,
            "total": total,
            "has_more": has_more,
        }

    async def get_message(
        self, message_id: str, user_id: str
    ) -> dict:
        """
        获取单条消息

        Args:
            message_id: 消息 ID
            user_id: 用户 ID

        Returns:
            消息信息

        Raises:
            NotFoundError: 消息不存在
            PermissionDeniedError: 无权访问
        """
        result = (
            self.db.table("messages")
            .select("*, conversations!inner(user_id)")
            .eq("id", message_id)
            .execute()
        )

        if not result.data:
            raise NotFoundError("消息", message_id)

        message = result.data[0]

        # 验证权限（通过关联的对话）
        if message["conversations"]["user_id"] != user_id:
            raise PermissionDeniedError("无权访问此消息")

        return self._format_message(message)

    async def send_message(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        model_id: Optional[str] = None,
        image_url: Optional[str] = None,
        video_url: Optional[str] = None,
    ) -> dict:
        """
        发送消息并获取 AI 响应

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID
            content: 消息内容
            model_id: 模型 ID（可选，默认 gemini-3-flash）
            image_url: 图片 URL（可选，用于 VQA）
            video_url: 视频 URL（可选，用于视频 QA）

        Returns:
            用户消息和 AI 响应
        """
        # 创建用户消息
        user_message = await self.create_message(
            conversation_id=conversation_id,
            user_id=user_id,
            content=content,
            role="user",
            image_url=image_url,
            video_url=video_url,
        )

        # 更新对话标题（如果是第一条消息）
        conversation = await self.conversation_service.get_conversation(
            conversation_id, user_id
        )
        if conversation["message_count"] == 1 and conversation["title"] == "新对话":
            new_title = content[:20] + ("..." if len(content) > 20 else "")
            await self.conversation_service.update_conversation(
                conversation_id, user_id, new_title
            )

        # 调用 AI 生成响应
        assistant_message = None
        credits_consumed = 0

        try:
            ai_response, credits = await self._call_ai_chat(
                conversation_id=conversation_id,
                user_id=user_id,
                user_message=content,
                model_id=model_id,
                image_url=image_url,
                video_url=video_url,
            )

            if ai_response:
                # 创建 assistant 消息
                assistant_message = await self.create_message(
                    conversation_id=conversation_id,
                    user_id=user_id,
                    content=ai_response,
                    role="assistant",
                    credits_cost=credits,
                )
                # 扣除用户积分
                await self._deduct_user_credits(
                    user_id=user_id,
                    credits=credits,
                    description="AI 对话",
                )
                credits_consumed = credits
        except KieAPIError as e:
            logger.error(
                f"AI call failed | conversation_id={conversation_id} | "
                f"user_id={user_id} | error={e.message}"
            )
            # AI 调用失败时返回错误提示消息
            assistant_message = await self.create_message(
                conversation_id=conversation_id,
                user_id=user_id,
                content="抱歉，AI 服务暂时不可用，请稍后重试。",
                role="assistant",
            )
        except Exception as e:
            logger.error(
                f"Unexpected error in AI call | conversation_id={conversation_id} | "
                f"user_id={user_id} | error={e}"
            )
            assistant_message = await self.create_message(
                conversation_id=conversation_id,
                user_id=user_id,
                content="抱歉，发生了意外错误，请稍后重试。",
                role="assistant",
            )

        return {
            "user_message": user_message,
            "assistant_message": assistant_message,
            "credits_consumed": credits_consumed,
        }

    async def _call_ai_chat(
        self,
        conversation_id: str,
        user_id: str,
        user_message: str,
        model_id: Optional[str] = None,
        image_url: Optional[str] = None,
        video_url: Optional[str] = None,
    ) -> tuple[str, int]:
        """
        调用 AI Chat 模型（非流式）

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID
            user_message: 用户消息
            model_id: 模型 ID
            image_url: 图片 URL（可选，用于 VQA）
            video_url: 视频 URL（可选，用于视频 QA）

        Returns:
            (AI 回复内容, 消耗积分)
        """
        settings = get_settings()

        if not settings.kie_api_key:
            raise KieAPIError("KIE API key not configured")

        # 默认使用 gemini-3-flash
        model = model_id if model_id in ("gemini-3-pro", "gemini-3-flash") else "gemini-3-flash"

        # 获取对话历史作为上下文
        history = await self._get_conversation_history(conversation_id, user_id)

        # 创建适配器并调用
        client = KieClient(settings.kie_api_key)
        adapter = KieChatAdapter(client, model)

        try:
            # 如果有图片或视频，使用 multimodal 消息
            if image_url or video_url:
                from services.adapters.kie.models import MessageRole

                messages = adapter.format_messages_from_history(history)

                # 收集所有媒体URL
                media_urls = []
                if image_url:
                    media_urls.append(image_url)
                if video_url:
                    media_urls.append(video_url)

                messages.append(
                    adapter.format_multimodal_message(
                        MessageRole.USER,
                        user_message,
                        media_urls
                    )
                )
                response = await adapter.chat(
                    messages=messages,
                    stream=False,
                    include_thoughts=False,
                    reasoning_effort=ReasoningEffort.HIGH,
                )
            else:
                response = await adapter.chat_simple(
                    user_message=user_message,
                    history=history,
                    stream=False,
                    include_thoughts=False,
                    reasoning_effort=ReasoningEffort.HIGH,
                )

            # 提取回复内容
            ai_content = ""
            if response.choices:
                delta = response.choices[0].delta
                ai_content = delta.content or ""

            # 计算积分消耗
            credits = 0
            if response.usage:
                cost = adapter.estimate_cost(
                    response.usage.prompt_tokens,
                    response.usage.completion_tokens,
                )
                credits = cost.estimated_credits

            logger.info(
                f"AI chat completed | conversation_id={conversation_id} | "
                f"model={model} | credits={credits}"
            )

            return ai_content, credits
        finally:
            await client.close()

    async def _get_conversation_history(
        self,
        conversation_id: str,
        user_id: str,
        limit: int = 10,
    ) -> List[Dict[str, Any]]:
        """
        获取对话历史（用于 AI 上下文）

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID
            limit: 历史消息数量限制

        Returns:
            格式化的历史消息列表
        """
        result = await self.get_messages(
            conversation_id=conversation_id,
            user_id=user_id,
            limit=limit,
        )

        history = []
        for msg in result["messages"]:
            if msg["role"] in ("user", "assistant"):
                msg_data = {
                    "role": msg["role"],
                    "content": msg["content"],
                }
                # 如果有图片或视频，添加到 attachments
                attachments = []
                if msg.get("image_url"):
                    attachments.append({
                        "type": "image",
                        "url": msg["image_url"]
                    })
                if msg.get("video_url"):
                    attachments.append({
                        "type": "video",
                        "url": msg["video_url"]
                    })
                if attachments:
                    msg_data["attachments"] = attachments
                history.append(msg_data)

        return history

    def _format_message(self, message: dict) -> dict:
        """格式化消息响应"""
        return {
            "id": message["id"],
            "conversation_id": message["conversation_id"],
            "role": message["role"],
            "content": message["content"],
            "image_url": message.get("image_url"),
            "video_url": message.get("video_url"),
            "credits_cost": message.get("credits_cost", 0),
            "created_at": message["created_at"],
        }

    async def _deduct_user_credits(
        self,
        user_id: str,
        credits: int,
        description: str = "AI 对话",
    ) -> None:
        """
        扣除用户积分

        Args:
            user_id: 用户 ID
            credits: 扣除的积分数
            description: 描述
        """
        if credits <= 0:
            return

        # 获取当前积分
        user_result = (
            self.db.table("users")
            .select("credits")
            .eq("id", user_id)
            .single()
            .execute()
        )

        if not user_result.data:
            logger.error(f"User not found for credits deduction | user_id={user_id}")
            return

        current_credits = user_result.data["credits"]
        new_balance = current_credits - credits

        # 更新用户积分
        self.db.table("users").update({
            "credits": new_balance
        }).eq("id", user_id).execute()

        # 记录积分历史
        self.db.table("credits_history").insert({
            "user_id": user_id,
            "change_amount": -credits,
            "balance_after": new_balance,
            "change_type": "conversation_cost",
            "description": description,
        }).execute()

        logger.info(
            f"Credits deducted | user_id={user_id} | credits={credits} | "
            f"balance_after={new_balance}"
        )

    async def _create_user_message_for_stream(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        image_url: Optional[str],
        video_url: Optional[str],
    ) -> Dict[str, Any]:
        """创建用户消息（流式场景）"""
        return await self.create_message(
            conversation_id=conversation_id,
            user_id=user_id,
            content=content,
            role="user",
            image_url=image_url,
            video_url=video_url,
        )

    async def _update_conversation_title_if_first_message(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
    ) -> None:
        """如果是第一条消息，更新对话标题"""
        conversation = await self.conversation_service.get_conversation(
            conversation_id, user_id
        )
        if conversation["message_count"] == 1 and conversation["title"] == "新对话":
            new_title = content[:20] + ("..." if len(content) > 20 else "")
            await self.conversation_service.update_conversation(
                conversation_id, user_id, new_title
            )

    def _prepare_ai_stream_client(
        self, model_id: Optional[str]
    ) -> tuple[str, KieClient, KieChatAdapter]:
        """准备AI流式客户端"""
        settings = get_settings()
        model = model_id if model_id in ("gemini-3-pro", "gemini-3-flash") else "gemini-3-flash"
        client = KieClient(settings.kie_api_key)
        adapter = KieChatAdapter(client, model)
        return model, client, adapter

    async def _stream_ai_response(
        self,
        adapter: KieChatAdapter,
        conversation_id: str,
        user_id: str,
        content: str,
        image_url: Optional[str],
        video_url: Optional[str],
    ) -> tuple[str, int, AsyncIterator]:
        """
        准备并返回AI流式响应

        Returns:
            (full_content, total_credits, stream) 元组
        """
        history = await self._get_conversation_history(conversation_id, user_id)

        # 根据是否有媒体选择不同的消息格式
        if image_url or video_url:
            from services.adapters.kie.models import MessageRole

            messages = adapter.format_messages_from_history(history)
            media_urls = []
            if image_url:
                media_urls.append(image_url)
            if video_url:
                media_urls.append(video_url)

            messages.append(
                adapter.format_multimodal_message(MessageRole.USER, content, media_urls)
            )
            stream = await adapter.chat(
                messages=messages,
                stream=True,
                include_thoughts=False,
                reasoning_effort=ReasoningEffort.HIGH,
            )
        else:
            stream = await adapter.chat_simple(
                user_message=content,
                history=history,
                stream=True,
                include_thoughts=False,
                reasoning_effort=ReasoningEffort.HIGH,
            )

        return stream

    async def _save_assistant_message_and_deduct_credits(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        credits: int,
        model: str,
    ) -> Dict[str, Any]:
        """保存 assistant 消息并扣除积分"""
        assistant_message = await self.create_message(
            conversation_id=conversation_id,
            user_id=user_id,
            content=content,
            role="assistant",
            credits_cost=credits,
        )
        await self._deduct_user_credits(
            user_id=user_id,
            credits=credits,
            description=f"AI 对话 ({model})",
        )
        return assistant_message

    async def _create_error_message(
        self,
        conversation_id: str,
        user_id: str,
        error_text: str,
    ) -> Dict[str, Any]:
        """创建错误消息"""
        return await self.create_message(
            conversation_id=conversation_id,
            user_id=user_id,
            content=error_text,
            role="assistant",
        )

    async def send_message_stream(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        model_id: Optional[str] = None,
        image_url: Optional[str] = None,
        video_url: Optional[str] = None,
    ) -> AsyncIterator[str]:
        """
        流式发送消息并获取 AI 响应

        Args:
            conversation_id: 对话 ID
            user_id: 用户 ID
            content: 消息内容
            model_id: 模型 ID
            image_url: 图片 URL（可选，用于 VQA）
            video_url: 视频 URL（可选，用于视频 QA）

        Yields:
            SSE 格式的流式数据
        """
        import json

        # 1. 创建用户消息并发送事件
        user_message = await self._create_user_message_for_stream(
            conversation_id, user_id, content, image_url, video_url
        )
        yield f"data: {json.dumps({'type': 'user_message', 'data': user_message})}\n\n"

        # 2. 更新对话标题（如果需要）
        await self._update_conversation_title_if_first_message(
            conversation_id, user_id, content
        )

        # 3. 检查AI服务配置
        settings = get_settings()
        if not settings.kie_api_key:
            yield f"data: {json.dumps({'type': 'error', 'data': {'message': 'AI 服务未配置'}})}\n\n"
            yield "data: [DONE]\n\n"
            return

        # 4. 准备AI客户端
        model, client, adapter = self._prepare_ai_stream_client(model_id)

        full_content = ""
        total_credits = 0

        try:
            # 发送开始事件
            yield f"data: {json.dumps({'type': 'start', 'data': {'model': model}})}\n\n"

            # 5. 流式获取AI响应
            stream = await self._stream_ai_response(
                adapter, conversation_id, user_id, content, image_url, video_url
            )

            async for chunk in stream:
                if chunk.choices:
                    delta = chunk.choices[0].delta
                    if delta.content:
                        full_content += delta.content
                        # 发送内容块
                        yield f"data: {json.dumps({'type': 'content', 'data': {'text': delta.content}})}\n\n"

                # 最后一个 chunk 包含 usage 信息
                if chunk.usage:
                    cost = adapter.estimate_cost(
                        chunk.usage.prompt_tokens,
                        chunk.usage.completion_tokens,
                    )
                    total_credits = cost.estimated_credits

            # 6. 保存消息并扣除积分
            if full_content:
                assistant_message = await self._save_assistant_message_and_deduct_credits(
                    conversation_id, user_id, full_content, total_credits, model
                )
                yield f"data: {json.dumps({'type': 'done', 'data': {'assistant_message': assistant_message, 'credits_consumed': total_credits}})}\n\n"
            else:
                yield f"data: {json.dumps({'type': 'done', 'data': {'assistant_message': None, 'credits_consumed': 0}})}\n\n"

        except KieAPIError as e:
            logger.error(
                f"AI stream failed | conversation_id={conversation_id} | "
                f"user_id={user_id} | error={e.message}"
            )
            error_msg = await self._create_error_message(
                conversation_id, user_id, "抱歉，AI 服务暂时不可用，请稍后重试。"
            )
            yield f"data: {json.dumps({'type': 'error', 'data': {'message': str(e.message), 'assistant_message': error_msg}})}\n\n"
        except Exception as e:
            logger.error(
                f"Unexpected error in AI stream | conversation_id={conversation_id} | "
                f"user_id={user_id} | error={e}"
            )
            error_msg = await self._create_error_message(
                conversation_id, user_id, "抱歉，发生了意外错误，请稍后重试。"
            )
            yield f"data: {json.dumps({'type': 'error', 'data': {'message': str(e), 'assistant_message': error_msg}})}\n\n"
        finally:
            await client.close()
            yield "data: [DONE]\n\n"
