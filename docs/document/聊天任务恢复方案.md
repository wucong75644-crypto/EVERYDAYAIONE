# 聊天任务恢复方案

> **版本**：v2.4 | **日期**：2026-02-04 | **状态**：确认实施（含断点续传 + 保底计费 + 同源说明）

## 一、需求整理

### 1.1 用户场景

| 场景 | 刷新时状态 | 刷新后预期 |
|------|----------|-----------|
| **文字聊天** | 占位符显示，模型未返回 | 用户消息+占位符恢复，等待模型返回 |
| **文字聊天** | 流式输出中 | 用户消息+已输出内容恢复，**继续输出** |
| **文字聊天** | 刷新过程中完成/失败 | 直接显示完成/失败内容 |
| **图片/视频** | 占位符显示 | 用户消息+占位符恢复，轮询继续 |
| **图片/视频** | 刷新过程中完成 | 直接显示成功/失败内容 |

### 1.2 多任务并发场景

| 任务类型 | 单对话多任务 | 多对话多任务 |
|----------|-------------|-------------|
| **聊天** | ❌ 不允许（AI回复完成前发送按钮禁用） | ✅ 允许 |
| **图片/视频** | ✅ 允许 | ✅ 允许 |

**恢复顺序要求**：
- 显示顺序 = 发送顺序（由 `created_at` 时间戳保证，前端排序）
- 占位符位置不变（由预分配 `assistant_message_id` + `created_at` 保证）
- 恢复可并发执行，先完成的先显示内容，不影响其他任务的占位符位置

```
示例：刷新前（用户发送顺序）
对话A：用户消息1 → [占位符1 pending]
对话B：用户消息2 → [占位符2 pending]
对话A：图片任务3 → [占位符3 pending]

刷新后恢复（假设任务2先完成）：
对话A：用户消息1 → [占位符1 恢复中...]
对话B：用户消息2 → [完整内容2]  ← 先完成就正常显示
对话A：图片任务3 → [占位符3 恢复中...]
```

### 1.3 核心要求

- 刷新后能恢复未完成任务
- **继续接收后续结果**（不只是显示已有内容）
- 用户消息、占位符、流式内容都能恢复
- **多任务并发恢复**，显示顺序由时间戳保证

---

## 二、架构设计：后台协程模式

### 2.1 核心思路

**任务执行完全放到后端，前端只负责同步**

- 后端使用 `asyncio.create_task()` 创建后台协程处理流式响应
- SSE 只负责"转发"，通过 `asyncio.Queue` 从后台协程接收数据
- **即使 SSE 断开，后台协程继续处理，直到完成或超时**
- 前端刷新后通过 `/tasks/{task_id}/stream` 恢复 SSE 连接

### 2.2 改造后流程

```
【首次请求】
前端发起 SSE 请求
    ↓
后端创建 chat 任务（status=pending）→ 返回 task_id
    ↓
后端启动后台协程处理流（独立于 SSE 连接）
    ↓
SSE 转发后台协程的输出 ← asyncio.Queue
    ↓
后台协程：每 500ms 更新 accumulated_content
    ↓
后台协程完成 → status=completed → 创建消息

【刷新恢复】
前端获取 /tasks/pending → 发现 chat 任务
    ↓
显示 accumulated_content（已有内容）
    ↓
连接 /tasks/{task_id}/stream → 继续接收流式内容
    ↓
后台协程完成 → 前端收到 done 事件
```

### 2.3 关键技术点

| 技术点 | 实现方式 |
|--------|---------|
| 后台协程独立运行 | `asyncio.create_task()` 创建的任务在 FastAPI 请求结束后继续运行 |
| SSE 与后台协程通信 | `asyncio.Queue` 无界队列，put_nowait 非阻塞写入 |
| SSE 断开不影响后台 | 后台协程捕获 queue.put_nowait 失败，继续处理 |
| 恢复流式连接 | 新 SSE 连接订阅同一个 Queue（或从数据库轮询） |
| 僵尸任务清理 | BackgroundTaskWorker 检测超时的 chat 任务 |

### 2.4 边界问题处理（v2.1 新增）

#### 2.4.1 并发竞争问题

**场景**：刷新瞬间，旧 SSE 连接可能还没完全断开，新连接就进来了。

**问题**：两个 SSE 连接同时从一个 `asyncio.Queue` 获取数据，导致消息流"跳跃"显示。

**解决方案**：采用**广播模式** + **连接版本号**

```python
class ChatStreamManager:
    def __init__(self):
        # task_id -> StreamState
        self._active_streams: Dict[str, StreamState] = {}

    @dataclass
    class StreamState:
        task: asyncio.Task
        subscribers: Dict[str, asyncio.Queue]  # connection_id -> Queue
        connection_version: int = 0
        buffer: List[str] = field(default_factory=list)  # 历史消息缓冲

    def subscribe(self, task_id: str, connection_id: str) -> tuple[asyncio.Queue, int]:
        """新连接订阅，返回 (queue, version)"""
        state = self._active_streams.get(task_id)
        if not state:
            return None, 0

        state.connection_version += 1
        queue = asyncio.Queue()
        state.subscribers[connection_id] = queue

        # 发送历史缓冲消息（恢复连接时补齐）
        for msg in state.buffer:
            queue.put_nowait(msg)

        return queue, state.connection_version

    def unsubscribe(self, task_id: str, connection_id: str):
        """断开订阅"""
        state = self._active_streams.get(task_id)
        if state:
            state.subscribers.pop(connection_id, None)

    def _broadcast(self, task_id: str, data: Any):
        """广播给所有订阅者"""
        state = self._active_streams.get(task_id)
        if not state:
            return

        msg = f"data: {json.dumps(data)}\n\n" if data else None

        # 保存到缓冲区（最多保留 1000 条）
        if msg:
            state.buffer.append(msg)
            if len(state.buffer) > 1000:
                state.buffer.pop(0)

        # 广播给所有订阅者
        for conn_id, queue in list(state.subscribers.items()):
            try:
                queue.put_nowait(msg)
            except asyncio.QueueFull:
                pass  # 消费者太慢，跳过
```

#### 2.4.2 数据库最终一致性

**场景**：协程在最后一个 chunk 处理完但 `db.update()` 执行前崩溃。

**问题**：`accumulated_content` 可能不完整，状态停留在 `running`。

**解决方案**：在 `finally` 块增加最终状态检查

```python
async def _process_stream(self, ...):
    full_content = ""
    completed_normally = False

    try:
        # ... 正常处理逻辑 ...
        completed_normally = True
    except Exception as e:
        # ... 错误处理 ...
    finally:
        # 【关键】最终一致性保障
        if not completed_normally and full_content:
            try:
                # 检查数据库状态
                task = db.table("tasks").select("status").eq("id", task_id).single().execute()
                if task.data and task.data["status"] in ("pending", "running"):
                    logger.warning(f"Ensuring final content sync: task_id={task_id}")
                    db.table("tasks").update({
                        "accumulated_content": full_content,
                        "status": "failed",
                        "error_message": "处理异常中断",
                        "completed_at": datetime.now(timezone.utc).isoformat(),
                    }).eq("id", task_id).execute()
            except Exception as sync_error:
                logger.error(f"Final sync failed: task_id={task_id}, error={sync_error}")

        # 广播结束信号
        self._broadcast(task_id, None)
```

#### 2.4.3 前端幂等性恢复

**场景**：用户疯狂按 F5 刷新。

**问题**：`onRehydrateStorage` 的 `setTimeout(100ms)` 在高频刷新下可能并发。

**解决方案**：使用全局单例 + AbortController

```typescript
// taskRestoration.ts
const activeRecoveries = new Map<string, AbortController>();

async function resumeChatStream(taskId: string, conversationId: string) {
  // 1. 检查是否已有活动恢复
  if (activeRecoveries.has(taskId)) {
    console.log(`Recovery already in progress: ${taskId}`);
    return;
  }

  // 2. 创建 AbortController
  const controller = new AbortController();
  activeRecoveries.set(taskId, controller);

  try {
    // 3. 连接 SSE
    const eventSource = new EventSource(`/api/tasks/${taskId}/stream`);

    controller.signal.addEventListener('abort', () => {
      eventSource.close();
    });

    // ... SSE 处理逻辑 ...

  } finally {
    activeRecoveries.delete(taskId);
  }
}

// 取消所有恢复（页面卸载前调用）
export function cancelAllRecoveries() {
  activeRecoveries.forEach((controller) => controller.abort());
  activeRecoveries.clear();
}
```

#### 2.4.4 反向代理超时

**场景**：Nginx/Cloudflare 默认 `proxy_read_timeout` 通常是 60s。

**问题**：心跳间隔正好 60s 容易触发 HTTP 504。

**解决方案**：心跳间隔缩短至 **30s**

```python
# ChatStreamManager / task.py
HEARTBEAT_INTERVAL = 30  # 秒

while True:
    try:
        item = await asyncio.wait_for(queue.get(), timeout=HEARTBEAT_INTERVAL)
        if item is None:
            break
        yield item
    except asyncio.TimeoutError:
        yield ": heartbeat\n\n"  # SSE 注释格式心跳
```

#### 2.4.5 消息 ID 映射

**场景**：刷新恢复后，`streaming-{taskId}` 切换到真实消息 ID 时 UI 闪烁。

**问题**：React Key 变化导致组件重新挂载。

**解决方案**：**预分配消息 ID**

```sql
-- tasks 表新增字段
ALTER TABLE tasks ADD COLUMN assistant_message_id UUID;
```

```python
# message_stream_service.py
async def send_message_stream(...):
    # 创建任务时预分配消息 ID
    assistant_message_id = str(uuid.uuid4())

    self.db.table("tasks").insert({
        "id": task_id,
        # ...
        "assistant_message_id": assistant_message_id,  # 预分配
    }).execute()

    # 返回给前端
    yield f"data: {json.dumps({
        'type': 'task_created',
        'data': {
            'task_id': task_id,
            'assistant_message_id': assistant_message_id,  # 前端用这个 ID
        }
    })}\n\n"
```

```typescript
// 前端使用固定 ID
function restoreChatTask(task: PendingTask) {
  const streamingMessage = {
    id: task.assistant_message_id,  // 使用预分配的固定 ID
    // ...
  };
}
```

#### 2.4.6 多标签页实时同步（v2.2 新增）

**场景**：用户在多个浏览器标签页打开同一应用。

**问题**：
- 标签页 A 完成聊天，标签页 B 不知道
- 切换标签页后需要手动刷新才能看到最新状态
- 多标签页可能重复恢复同一任务

**解决方案**：使用 **BroadcastChannel API** 实现标签页间实时通信

```typescript
// utils/tabSync.ts
const CHANNEL_NAME = 'everydayai-sync';

export type TabSyncEventType =
  | 'chat_started'      // 聊天开始
  | 'chat_completed'    // 聊天完成
  | 'chat_failed'       // 聊天失败
  | 'task_restored'     // 任务已被其他标签页恢复
  | 'message_updated'   // 消息更新
  | 'credits_changed';  // 积分变化

interface TabSyncEvent {
  type: TabSyncEventType;
  payload: {
    conversationId?: string;
    taskId?: string;
    messageId?: string;
    [key: string]: unknown;
  };
  timestamp: number;
  tabId: string;
}

class TabSyncManager {
  private channel: BroadcastChannel;
  private tabId: string;
  private listeners: Map<TabSyncEventType, Set<(payload: any) => void>>;

  constructor() {
    this.tabId = `tab-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    this.listeners = new Map();

    if (typeof window !== 'undefined' && 'BroadcastChannel' in window) {
      this.channel = new BroadcastChannel(CHANNEL_NAME);
      this.channel.onmessage = this.handleMessage.bind(this);
    }
  }

  /**
   * 广播事件给其他标签页
   */
  broadcast(type: TabSyncEventType, payload: TabSyncEvent['payload']) {
    if (!this.channel) return;

    const event: TabSyncEvent = {
      type,
      payload,
      timestamp: Date.now(),
      tabId: this.tabId,
    };

    this.channel.postMessage(event);
  }

  /**
   * 监听特定事件
   */
  on(type: TabSyncEventType, callback: (payload: any) => void) {
    if (!this.listeners.has(type)) {
      this.listeners.set(type, new Set());
    }
    this.listeners.get(type)!.add(callback);

    // 返回取消监听函数
    return () => {
      this.listeners.get(type)?.delete(callback);
    };
  }

  /**
   * 处理来自其他标签页的消息
   */
  private handleMessage(event: MessageEvent<TabSyncEvent>) {
    const { type, payload, tabId } = event.data;

    // 忽略自己发送的消息
    if (tabId === this.tabId) return;

    // 通知所有监听者
    const listeners = this.listeners.get(type);
    if (listeners) {
      listeners.forEach(callback => callback(payload));
    }
  }

  /**
   * 销毁（页面卸载时调用）
   */
  destroy() {
    if (this.channel) {
      this.channel.close();
    }
    this.listeners.clear();
  }
}

// 全局单例
export const tabSync = new TabSyncManager();

// 页面卸载时清理
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => tabSync.destroy());
}
```

**使用场景**：

```typescript
// 1. 聊天完成时广播
// useMessageCallbacks.tsx
const handleMessageSent = (aiMessage: Message) => {
  // ... 原有逻辑 ...

  // 广播给其他标签页
  tabSync.broadcast('chat_completed', {
    conversationId: aiMessage.conversation_id,
    messageId: aiMessage.id,
  });
};

// 2. 任务恢复时广播（防止重复恢复）
// taskRestoration.ts
async function resumeChatStream(taskId: string, conversationId: string) {
  // ... 原有逻辑 ...

  // 广播：告诉其他标签页这个任务已被恢复
  tabSync.broadcast('task_restored', {
    taskId,
    conversationId,
  });
}

// 3. 其他标签页监听并响应
// Chat.tsx 或 App.tsx
useEffect(() => {
  // 监听聊天完成
  const unsubChat = tabSync.on('chat_completed', (payload) => {
    // 刷新对应对话的消息列表
    if (payload.conversationId === currentConversationId) {
      invalidateMessages(payload.conversationId);
    }
    // 更新侧边栏未读数
    markConversationUnread(payload.conversationId);
  });

  // 监听任务恢复（避免重复恢复）
  const unsubTask = tabSync.on('task_restored', (payload) => {
    // 标记任务已被其他标签页恢复，本标签页跳过
    skipRecovery.add(payload.taskId);
  });

  return () => {
    unsubChat();
    unsubTask();
  };
}, [currentConversationId]);
```

**效果**：
- ✅ 标签页 A 完成聊天 → 标签页 B/C 实时显示新消息
- ✅ 标签页 A 恢复任务 → 标签页 B/C 不会重复恢复
- ✅ 积分变化 → 所有标签页实时更新余额

---

## 三、数据库变更

### 3.1 tasks 表新增字段

```sql
-- 累积的流式内容（每 500ms 更新一次）
ALTER TABLE tasks ADD COLUMN accumulated_content TEXT;

-- 聊天任务相关字段
ALTER TABLE tasks ADD COLUMN model_id VARCHAR(100);
ALTER TABLE tasks ADD COLUMN total_credits INTEGER DEFAULT 0;

-- 预分配的助手消息 ID（解决 ID 映射闪烁问题）
ALTER TABLE tasks ADD COLUMN assistant_message_id UUID;
```

### 3.2 chat 任务字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| id | uuid | 任务 ID（同时作为 external_task_id） |
| type | varchar | `chat`（新增类型） |
| conversation_id | uuid | 对话 ID |
| user_id | uuid | 用户 ID |
| status | varchar | pending / running / completed / failed |
| request_params | jsonb | 请求参数（content, image_url, video_url） |
| accumulated_content | text | 累积的流式内容 |
| model_id | varchar | 使用的模型 |
| total_credits | integer | 消耗的积分 |
| assistant_message_id | uuid | 预分配的助手消息 ID（避免 UI 闪烁） |
| started_at | timestamp | 开始时间 |
| completed_at | timestamp | 完成时间 |
| error_message | text | 错误信息（失败时） |

---

## 四、后端改造

### 4.1 新增 ChatStreamManager（核心，含边界处理）

新建 `backend/services/chat_stream_manager.py`：

```python
"""
聊天流管理器

管理后台流式处理协程，支持：
- SSE 断开后继续处理
- 多连接广播（解决并发竞争）
- 最终一致性保障
- 心跳超时优化
"""

import asyncio
import json
import time
import uuid
from dataclasses import dataclass, field
from typing import Dict, Optional, Any, List
from datetime import datetime, timezone

from loguru import logger
from supabase import Client

from services.message_service import MessageService
from services.message_utils import deduct_user_credits


# 心跳间隔（避免网关超时）
HEARTBEAT_INTERVAL = 30  # 秒
# 消息缓冲区大小（用于恢复连接时补发）
MAX_BUFFER_SIZE = 500
# 数据库更新节流间隔
DB_UPDATE_INTERVAL = 0.5  # 秒


@dataclass
class StreamState:
    """单个流任务的状态"""
    task: asyncio.Task
    subscribers: Dict[str, asyncio.Queue] = field(default_factory=dict)  # connection_id -> Queue
    connection_version: int = 0
    buffer: List[str] = field(default_factory=list)  # 历史消息缓冲（用于恢复连接）
    full_content: str = ""  # 累积的完整内容


class ChatStreamManager:
    """聊天流管理器 - 管理后台流式处理协程"""

    def __init__(self):
        # task_id -> StreamState
        self._active_streams: Dict[str, StreamState] = {}
        self._lock = asyncio.Lock()

    def is_active(self, task_id: str) -> bool:
        """检查任务是否还在处理中"""
        return task_id in self._active_streams

    async def subscribe(
        self, task_id: str, connection_id: Optional[str] = None,
        last_received_index: int = -1  # 【断点续传】上次收到的消息索引
    ) -> tuple[Optional[asyncio.Queue], str, str, int]:
        """
        新连接订阅任务流

        Args:
            task_id: 任务 ID
            connection_id: 连接 ID（可选，自动生成）
            last_received_index: 上次收到的消息索引（-1 表示从头开始）

        Returns:
            (queue, accumulated_content_so_far, connection_id, current_buffer_index)
            如果任务不活跃，返回 (None, "", "", 0)
        """
        async with self._lock:
            state = self._active_streams.get(task_id)
            if not state:
                return None, "", "", 0

            if not connection_id:
                connection_id = str(uuid.uuid4())

            state.connection_version += 1
            queue: asyncio.Queue = asyncio.Queue()
            state.subscribers[connection_id] = queue

            # 【断点续传】只发送 last_received_index 之后的缓冲消息
            # 避免网络波动重连时收到重复内容
            start_index = max(0, last_received_index + 1)
            if start_index < len(state.buffer):
                for i, msg in enumerate(state.buffer[start_index:], start=start_index):
                    queue.put_nowait((i, msg))  # 附带索引

            # 返回已累积的内容和当前缓冲区索引
            return queue, state.full_content, connection_id, len(state.buffer) - 1

    async def unsubscribe(self, task_id: str, connection_id: str):
        """断开订阅"""
        async with self._lock:
            state = self._active_streams.get(task_id)
            if state:
                state.subscribers.pop(connection_id, None)

    async def start_stream_processing(
        self,
        db: Client,
        message_service: MessageService,
        task_id: str,
        conversation_id: str,
        user_id: str,
        assistant_message_id: str,  # 预分配的消息 ID
        stream,  # AsyncIterator from KIE
        model: str,
        adapter,  # KieChatAdapter for cost calculation
    ) -> tuple[asyncio.Queue, str]:
        """
        启动后台流处理协程

        Returns:
            (queue, connection_id): 用于接收流式输出的队列和连接 ID
        """
        connection_id = str(uuid.uuid4())
        queue: asyncio.Queue = asyncio.Queue()

        state = StreamState(
            task=None,  # 稍后设置
            subscribers={connection_id: queue},
            connection_version=1,
        )

        # 启动后台协程
        task = asyncio.create_task(
            self._process_stream(
                db, message_service, task_id, conversation_id,
                user_id, assistant_message_id, stream, model, adapter, state
            )
        )
        state.task = task

        async with self._lock:
            self._active_streams[task_id] = state

        # 任务完成后自动清理
        def cleanup(_):
            self._active_streams.pop(task_id, None)
        task.add_done_callback(cleanup)

        return queue, connection_id

    async def _process_stream(
        self,
        db: Client,
        message_service: MessageService,
        task_id: str,
        conversation_id: str,
        user_id: str,
        assistant_message_id: str,
        stream,
        model: str,
        adapter,
        state: StreamState,
    ):
        """后台流处理协程 - 独立于 SSE 连接运行"""
        total_credits = 0
        last_update_time = time.time()
        completed_normally = False

        try:
            # 更新状态为 running
            db.table("tasks").update({
                "status": "running",
            }).eq("id", task_id).execute()

            # 广播 start 事件
            self._broadcast(task_id, state, {
                "type": "start",
                "data": {"model": model}
            })

            async for chunk in stream:
                if chunk.choices and chunk.choices[0].delta.content:
                    delta_content = chunk.choices[0].delta.content
                    state.full_content += delta_content

                    # 广播 content 事件
                    self._broadcast(task_id, state, {
                        "type": "content",
                        "data": {"text": delta_content}
                    })

                    # 节流更新数据库
                    if time.time() - last_update_time > DB_UPDATE_INTERVAL:
                        db.table("tasks").update({
                            "accumulated_content": state.full_content,
                        }).eq("id", task_id).execute()
                        last_update_time = time.time()

                # 【关键】计算积分（捕获最后一帧的 usage）
                # 注意：某些 Provider（如 OpenAI）会在流结束后的最后一帧才返回 usage
                # 需要确保 adapter 正确设置 stream_options={"include_usage": True}
                # 否则会导致 usage 为 None，计费丢失
                if chunk.usage:
                    cost = adapter.estimate_cost(
                        chunk.usage.prompt_tokens,
                        chunk.usage.completion_tokens,
                    )
                    total_credits = cost.estimated_credits

            # 完成：创建消息 + 更新任务状态
            if state.full_content:
                # 【保底计费】如果 usage 未返回（异常中断/content_filter 等）
                # 按内容长度估算，防止积分流失
                if total_credits == 0 and len(state.full_content) > 0:
                    # 保底估算：假设 1 token ≈ 4 字符（中文约 1.5 字符）
                    estimated_tokens = max(len(state.full_content) // 3, 10)
                    total_credits = adapter.estimate_cost_by_tokens(
                        prompt_tokens=0,  # 无法估算输入
                        completion_tokens=estimated_tokens,
                    ).estimated_credits
                    logger.warning(
                        f"Usage not received, fallback estimation: "
                        f"task_id={task_id}, content_len={len(state.full_content)}, "
                        f"estimated_credits={total_credits}"
                    )

                assistant_message = await message_service.create_message(
                    conversation_id=conversation_id,
                    user_id=user_id,
                    content=state.full_content,
                    role="assistant",
                    credits_cost=total_credits,
                    message_id=assistant_message_id,  # 使用预分配的 ID
                )
                await deduct_user_credits(
                    db, user_id, total_credits, f"AI 对话 ({model})"
                )

                db.table("tasks").update({
                    "status": "completed",
                    "accumulated_content": state.full_content,
                    "total_credits": total_credits,
                    "completed_at": datetime.now(timezone.utc).isoformat(),
                }).eq("id", task_id).execute()

                # 广播 done 事件
                self._broadcast(task_id, state, {
                    "type": "done",
                    "data": {
                        "assistant_message": assistant_message,
                        "credits_consumed": total_credits
                    }
                })
            else:
                # 无内容也标记完成
                db.table("tasks").update({
                    "status": "completed",
                    "completed_at": datetime.now(timezone.utc).isoformat(),
                }).eq("id", task_id).execute()

                self._broadcast(task_id, state, {
                    "type": "done",
                    "data": {"assistant_message": None, "credits_consumed": 0}
                })

            completed_normally = True
            logger.info(f"Chat stream completed: task_id={task_id}")

        except Exception as e:
            logger.error(f"Chat stream failed: task_id={task_id}, error={e}")

            # 创建错误消息
            error_message = await message_service.create_error_message(
                conversation_id=conversation_id,
                user_id=user_id,
                content="抱歉，AI 服务暂时不可用，请稍后重试。",
                message_id=assistant_message_id,  # 使用预分配的 ID
            )

            db.table("tasks").update({
                "status": "failed",
                "error_message": str(e),
                "accumulated_content": state.full_content,
                "completed_at": datetime.now(timezone.utc).isoformat(),
            }).eq("id", task_id).execute()

            # 广播 error 事件
            self._broadcast(task_id, state, {
                "type": "error",
                "data": {
                    "message": "抱歉，AI 服务暂时不可用，请稍后重试。",
                    "error_message": error_message
                }
            })

        finally:
            # 【关键】最终一致性保障
            if not completed_normally and state.full_content:
                try:
                    task = db.table("tasks").select("status").eq("id", task_id).single().execute()
                    if task.data and task.data["status"] in ("pending", "running"):
                        logger.warning(f"Ensuring final content sync: task_id={task_id}")
                        db.table("tasks").update({
                            "accumulated_content": state.full_content,
                            "status": "failed",
                            "error_message": "处理异常中断",
                            "completed_at": datetime.now(timezone.utc).isoformat(),
                        }).eq("id", task_id).execute()
                except Exception as sync_error:
                    logger.error(f"Final sync failed: task_id={task_id}, error={sync_error}")

            # 广播结束信号
            self._broadcast(task_id, state, None)

    def _broadcast(self, task_id: str, state: StreamState, data: Any):
        """广播给所有订阅者"""
        if data is None:
            msg = None
            msg_index = -1
        else:
            # 【断点续传】消息中附带索引，方便前端记录
            msg_index = len(state.buffer)
            data_with_index = {**data, "_index": msg_index}
            msg = f"data: {json.dumps(data_with_index)}\n\n"

        # 保存到缓冲区（用于恢复连接时补发，限制大小）
        if msg:
            state.buffer.append(msg)
            if len(state.buffer) > MAX_BUFFER_SIZE:
                # 移除最旧的消息，但索引保持连续性
                state.buffer.pop(0)

        # 广播给所有订阅者
        dead_connections = []
        for conn_id, queue in state.subscribers.items():
            try:
                queue.put_nowait(msg)
            except asyncio.QueueFull:
                # 消费者太慢，标记为死连接
                dead_connections.append(conn_id)
            except Exception as e:
                logger.warning(f"Broadcast failed: conn_id={conn_id}, error={e}")
                dead_connections.append(conn_id)

        # 清理死连接
        for conn_id in dead_connections:
            state.subscribers.pop(conn_id, None)


# 全局单例
chat_stream_manager = ChatStreamManager()
```

### 4.2 message_stream_service.py 改造（含边界处理）

```python
"""
流式消息服务（改造版）

使用 ChatStreamManager 实现后台协程处理
- 支持预分配消息 ID（避免 UI 闪烁）
- 30s 心跳（避免网关超时）
"""

import asyncio
import json
import uuid
from typing import Optional, AsyncIterator, TYPE_CHECKING
from datetime import datetime, timezone

from loguru import logger
from supabase import Client

from core.config import get_settings
from services.adapters.kie.client import KieAPIError
from services.message_utils import format_message
from services.message_ai_helpers import prepare_ai_stream_client, stream_ai_response
from services.chat_stream_manager import chat_stream_manager, HEARTBEAT_INTERVAL

if TYPE_CHECKING:
    from datetime import datetime
    from services.message_service import MessageService
    from services.conversation_service import ConversationService


class MessageStreamService:
    """流式消息服务类"""

    def __init__(
        self,
        db: Client,
        message_service: "MessageService",
        conversation_service: "ConversationService",
    ) -> None:
        self.db = db
        self.message_service = message_service
        self.conversation_service = conversation_service

    async def send_message_stream(
        self,
        conversation_id: str,
        user_id: str,
        content: str,
        model_id: Optional[str] = None,
        image_url: Optional[str] = None,
        video_url: Optional[str] = None,
        thinking_effort: Optional[str] = None,
        thinking_mode: Optional[str] = None,
        client_request_id: Optional[str] = None,
        created_at: Optional["datetime"] = None,
    ) -> AsyncIterator[str]:
        """流式发送消息并获取 AI 响应（后台协程模式）"""

        # 1. 创建用户消息
        user_message = await self.message_service.create_message(
            conversation_id, user_id, content, "user", 0, image_url, video_url,
            client_request_id=client_request_id,
            created_at=created_at,
        )
        yield f"data: {json.dumps({'type': 'user_message', 'data': {'user_message': user_message}})}\n\n"

        # 2. 更新对话标题
        await self.message_service._update_conversation_title_if_first_message(
            conversation_id, user_id, content
        )

        # 3. 检查 AI 服务配置
        settings = get_settings()
        if not settings.kie_api_key:
            yield f"data: {json.dumps({'type': 'error', 'data': {'message': 'AI 服务未配置'}})}\n\n"
            yield "data: [DONE]\n\n"
            return

        # 4. 预分配 ID（解决 UI 闪烁问题）
        task_id = str(uuid.uuid4())
        assistant_message_id = str(uuid.uuid4())

        # 5. 创建 chat 任务记录
        self.db.table("tasks").insert({
            "id": task_id,
            "external_task_id": task_id,
            "user_id": user_id,
            "conversation_id": conversation_id,
            "type": "chat",
            "status": "pending",
            "request_params": {
                "content": content,
                "image_url": image_url,
                "video_url": video_url,
                "thinking_effort": thinking_effort,
                "thinking_mode": thinking_mode,
            },
            "model_id": model_id,
            "assistant_message_id": assistant_message_id,  # 预分配
            "credits_locked": 0,  # chat 不预扣积分
            "started_at": datetime.now(timezone.utc).isoformat(),
        }).execute()

        # 6. 返回 task_id 和预分配的消息 ID 给前端
        yield f"data: {json.dumps({'type': 'task_created', 'data': {'task_id': task_id, 'assistant_message_id': assistant_message_id}})}\n\n"

        # 7. 准备 AI 客户端
        model, client, adapter = prepare_ai_stream_client(model_id)
        connection_id = None

        try:
            # 8. 获取流式响应
            stream = await stream_ai_response(
                adapter=adapter,
                get_conversation_history_func=self.message_service._get_conversation_history,
                conversation_id=conversation_id,
                user_id=user_id,
                content=content,
                image_url=image_url,
                video_url=video_url,
                thinking_effort=thinking_effort,
                thinking_mode=thinking_mode,
            )

            # 9. 启动后台协程处理流
            queue, connection_id = await chat_stream_manager.start_stream_processing(
                db=self.db,
                message_service=self.message_service,
                task_id=task_id,
                conversation_id=conversation_id,
                user_id=user_id,
                assistant_message_id=assistant_message_id,
                stream=stream,
                model=model,
                adapter=adapter,
            )

            # 10. SSE 转发：从队列读取并发送给前端
            while True:
                try:
                    item = await asyncio.wait_for(queue.get(), timeout=HEARTBEAT_INTERVAL)
                    if item is None:  # 结束信号
                        break
                    yield item
                except asyncio.TimeoutError:
                    # 发送心跳保持连接（30s，避免网关超时）
                    yield ": heartbeat\n\n"

        except KieAPIError as e:
            logger.error(f"AI stream init failed: task_id={task_id}, error={e.message}")
            # 更新任务状态
            self.db.table("tasks").update({
                "status": "failed",
                "error_message": e.message,
                "completed_at": datetime.now(timezone.utc).isoformat(),
            }).eq("id", task_id).execute()

            async for event in self._handle_stream_error(
                conversation_id, user_id, "抱歉，AI 服务暂时不可用，请稍后重试。",
                message_id=assistant_message_id,
            ):
                yield event

        except Exception as e:
            logger.error(f"Unexpected error: task_id={task_id}, error={e}")
            self.db.table("tasks").update({
                "status": "failed",
                "error_message": str(e),
                "completed_at": datetime.now(timezone.utc).isoformat(),
            }).eq("id", task_id).execute()

            async for event in self._handle_stream_error(
                conversation_id, user_id, "发生了意外错误，请稍后重试。",
                message_id=assistant_message_id,
            ):
                yield event

        finally:
            # 取消订阅
            if connection_id:
                await chat_stream_manager.unsubscribe(task_id, connection_id)
            await client.close()
            yield "data: [DONE]\n\n"

    # ... 其他方法保持不变 ...
```

### 4.3 task.py 新增端点（含边界处理）

```python
from services.chat_stream_manager import chat_stream_manager, HEARTBEAT_INTERVAL


@router.get("/{task_id}/stream", summary="恢复聊天任务流式连接")
async def resume_chat_stream(
    request: Request,
    task_id: str,
    current_user: CurrentUser,
    db: Database,
    last_received_index: int = Query(-1, description="上次收到的消息索引，用于断点续传"),
):
    """
    恢复 chat 类型任务的 SSE 连接

    - 支持断点续传：传入 last_received_index 参数，只接收该索引之后的消息
    - 如果任务进行中且有活跃队列，直接订阅（广播模式，支持多连接）
    - 如果任务进行中但无队列（后台协程在处理），轮询数据库
    - 如果任务已完成，返回完整内容
    - 如果任务失败，返回错误
    """
    # 验证任务所有权
    task = db.table("tasks").select("*").eq(
        "id", task_id
    ).eq("user_id", current_user["id"]).single().execute()

    if not task.data:
        raise HTTPException(status_code=404, detail="任务不存在")

    task_data = task.data

    if task_data["type"] != "chat":
        raise HTTPException(status_code=400, detail="只支持 chat 类型任务")

    async def generate_stream():
        import json
        import asyncio

        connection_id = None

        try:
            # 1. 已完成：返回完整内容
            if task_data["status"] == "completed":
                # 使用预分配的消息 ID 获取消息
                assistant_message_id = task_data.get("assistant_message_id")
                if assistant_message_id:
                    msg = db.table("messages").select("*").eq(
                        "id", assistant_message_id
                    ).single().execute()
                    if msg.data:
                        yield f"data: {json.dumps({'type': 'done', 'data': {'assistant_message': msg.data}})}\n\n"
                else:
                    # 兼容旧数据
                    messages = db.table("messages").select("*").eq(
                        "conversation_id", task_data["conversation_id"]
                    ).order("created_at", desc=True).limit(1).execute()
                    if messages.data:
                        yield f"data: {json.dumps({'type': 'done', 'data': {'assistant_message': messages.data[0]}})}\n\n"
                yield "data: [DONE]\n\n"
                return

            # 2. 已失败：返回错误
            if task_data["status"] == "failed":
                yield f"data: {json.dumps({'type': 'error', 'data': {'message': task_data.get('error_message', '任务失败')}})}\n\n"
                yield "data: [DONE]\n\n"
                return

            # 3. 进行中：尝试订阅队列或轮询
            # 【断点续传】传入 last_received_index，只接收该索引之后的消息
            queue, accumulated_content, connection_id, current_index = await chat_stream_manager.subscribe(
                task_id, last_received_index=last_received_index
            )

            if queue:
                # 有活跃队列，订阅广播（支持多连接，不会竞争）
                # 【断点续传】只有首次连接（last_received_index=-1）才发送累积内容
                # 重连时通过 buffer 补发，避免重复
                if accumulated_content and last_received_index < 0:
                    yield f"data: {json.dumps({'type': 'accumulated', 'data': {'text': accumulated_content, '_index': current_index}})}\n\n"

                while True:
                    try:
                        item = await asyncio.wait_for(queue.get(), timeout=HEARTBEAT_INTERVAL)
                        if item is None:
                            break
                        yield item
                    except asyncio.TimeoutError:
                        # 30s 心跳，避免网关超时
                        yield ": heartbeat\n\n"
            else:
                # 无活跃队列（可能是进程重启后），轮询数据库
                last_content_length = len(task_data.get("accumulated_content") or "")

                # 先发送已有内容
                if task_data.get("accumulated_content"):
                    yield f"data: {json.dumps({'type': 'accumulated', 'data': {'text': task_data['accumulated_content']}})}\n\n"

                poll_count = 0
                max_polls = 600  # 最多轮询 10 分钟（1秒/次）

                while poll_count < max_polls:
                    await asyncio.sleep(1)
                    poll_count += 1

                    # 每 30 秒发送心跳
                    if poll_count % HEARTBEAT_INTERVAL == 0:
                        yield ": heartbeat\n\n"

                    # 重新查询任务状态
                    updated_task = db.table("tasks").select(
                        "status, accumulated_content, error_message, assistant_message_id"
                    ).eq("id", task_id).single().execute()

                    if not updated_task.data:
                        break

                    status = updated_task.data["status"]
                    current_content = updated_task.data.get("accumulated_content") or ""

                    # 发送新增内容（增量）
                    if len(current_content) > last_content_length:
                        new_content = current_content[last_content_length:]
                        yield f"data: {json.dumps({'type': 'content', 'data': {'text': new_content}})}\n\n"
                        last_content_length = len(current_content)

                    # 检查是否完成
                    if status == "completed":
                        assistant_message_id = updated_task.data.get("assistant_message_id")
                        if assistant_message_id:
                            msg = db.table("messages").select("*").eq(
                                "id", assistant_message_id
                            ).single().execute()
                            if msg.data:
                                yield f"data: {json.dumps({'type': 'done', 'data': {'assistant_message': msg.data}})}\n\n"
                        break

                    if status == "failed":
                        yield f"data: {json.dumps({'type': 'error', 'data': {'message': updated_task.data.get('error_message', '任务失败')}})}\n\n"
                        break

            yield "data: [DONE]\n\n"

        finally:
            # 清理订阅
            if connection_id:
                await chat_stream_manager.unsubscribe(task_id, connection_id)

    return StreamingResponse(
        generate_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
        },
    )


@router.get("/{task_id}/content", summary="获取聊天任务累积内容")
async def get_chat_task_content(
    task_id: str,
    current_user: CurrentUser,
    db: Database,
) -> Dict[str, Any]:
    """获取 chat 类型任务的当前状态和累积内容"""
    task = db.table("tasks").select(
        "id, status, accumulated_content, error_message, completed_at, "
        "conversation_id, assistant_message_id"
    ).eq("id", task_id).eq("user_id", current_user["id"]).single().execute()

    if not task.data:
        raise HTTPException(status_code=404, detail="任务不存在")

    return {
        "task_id": task_id,
        "status": task.data["status"],
        "accumulated_content": task.data.get("accumulated_content"),
        "error_message": task.data.get("error_message"),
        "completed_at": task.data.get("completed_at"),
        "conversation_id": task.data.get("conversation_id"),
        "assistant_message_id": task.data.get("assistant_message_id"),
    }
```

### 4.4 background_task_worker.py 支持 chat 类型

```python
async def cleanup_stale_tasks(self):
    """清理超时任务（包括 chat 类型）"""
    now = datetime.now(timezone.utc)

    response = self.db.table("tasks").select("*").in_(
        "status", ["pending", "running"]
    ).execute()

    cleaned_count = 0

    for task in response.data:
        started_at = datetime.fromisoformat(
            task["started_at"].replace("Z", "+00:00")
        )

        # chat 任务超时时间：10 分钟
        if task["type"] == "chat":
            max_duration_minutes = 10
        elif task["type"] == "image":
            max_duration_minutes = IMAGE_TASK_TIMEOUT_MINUTES
        else:
            max_duration_minutes = VIDEO_TASK_TIMEOUT_MINUTES

        if (now - started_at).total_seconds() > max_duration_minutes * 60:
            self.db.table("tasks").update({
                "status": "failed",
                "error_message": f"任务超时 (超过{max_duration_minutes}分钟)",
                "completed_at": now.isoformat(),
            }).eq("id", task["id"]).execute()

            cleaned_count += 1
            logger.warning(
                f"Task timeout: id={task['id']}, type={task['type']}"
            )

    if cleaned_count > 0:
        logger.info(f"Cleaned {cleaned_count} stale tasks")
```

### 4.5 /tasks/pending 返回 chat 任务的 accumulated_content

```python
@router.get("/pending", summary="获取用户进行中任务")
async def get_pending_tasks(
    request: Request,
    current_user: CurrentUser,
    db: Database,
) -> Dict[str, Any]:
    """获取当前用户所有进行中的任务"""
    response = db.table("tasks").select(
        "id, external_task_id, conversation_id, type, status, "
        "request_params, credits_locked, placeholder_message_id, "
        "placeholder_created_at, started_at, last_polled_at, "
        "accumulated_content, model_id, error_message"  # 新增字段
    ).eq("user_id", current_user["id"]).in_(
        "status", ["pending", "running"]
    ).order("started_at", desc=False).execute()

    return {
        "tasks": response.data,
        "count": len(response.data),
    }
```

---

## 五、前端改造

### 5.1 taskRestoration.ts 支持 chat 类型（含幂等性处理）

```typescript
import { useConversationRuntimeStore } from '@/stores/useConversationRuntimeStore';

// 【关键】活动恢复追踪（解决高频刷新并发问题）
const activeRecoveries = new Map<string, AbortController>();

/**
 * 取消所有恢复（页面卸载前调用）
 */
export function cancelAllRecoveries() {
  activeRecoveries.forEach((controller) => controller.abort());
  activeRecoveries.clear();
}

// 页面卸载前取消所有恢复
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', cancelAllRecoveries);
}

export async function restoreAllPendingTasks() {
  const tasks = await fetchPendingTasks();

  // 【并发恢复】多个任务同时恢复，不互相阻塞
  // 显示顺序由 created_at 时间戳保证，与恢复顺序无关
  const restorePromises = tasks.map((task) => {
    if (task.type === 'chat') {
      // chat 任务：恢复 SSE 流式连接（异步启动，不等待流完成）
      return restoreChatTask(task);
    } else {
      // 图片/视频任务：轮询模式（同步启动，内部异步）
      restoreTaskPolling(task);
      return Promise.resolve();
    }
  });

  // 等待所有恢复任务启动完成
  // 注意：这里只等待"启动"，不等待流式传输完成
  await Promise.all(restorePromises);
}

async function restoreChatTask(task: PendingTask) {
  const {
    id: taskId,
    conversation_id: conversationId,
    accumulated_content: accumulatedContent,
    assistant_message_id: assistantMessageId,  // 预分配的固定 ID
    status,
    error_message: errorMessage,
  } = task;

  const runtimeStore = useConversationRuntimeStore.getState();

  // 1. 如果有累积内容，创建 streaming 消息显示
  // 【关键】使用预分配的 assistant_message_id，避免 UI 闪烁
  if (accumulatedContent && (status === 'running' || status === 'pending')) {
    const streamingMessage = {
      id: assistantMessageId || `streaming-${taskId}`,  // 使用固定 ID
      conversation_id: conversationId,
      role: 'assistant' as const,
      content: accumulatedContent,
      created_at: new Date().toISOString(),
      credits_cost: 0,
    };

    runtimeStore.addStreamingMessage(conversationId, streamingMessage);
  }

  // 2. 根据状态处理
  if (status === 'running' || status === 'pending') {
    // 恢复 SSE 连接，继续接收流式内容
    await resumeChatStream(taskId, conversationId, assistantMessageId);
  } else if (status === 'completed') {
    // 已完成，重新加载消息列表
    await reloadConversationMessages(conversationId);
  } else if (status === 'failed') {
    // 失败，显示错误
    const errorMsg = {
      id: assistantMessageId || `error-${taskId}`,
      conversation_id: conversationId,
      role: 'assistant' as const,
      content: errorMessage || '生成失败，请重试',
      created_at: new Date().toISOString(),
      credits_cost: 0,
      is_error: true,
    };
    runtimeStore.addErrorMessage(conversationId, errorMsg);
  }
}

async function resumeChatStream(
  taskId: string,
  conversationId: string,
  assistantMessageId?: string,
) {
  // 【关键】幂等性检查：防止重复恢复
  if (activeRecoveries.has(taskId)) {
    console.log(`Recovery already in progress: ${taskId}`);
    return;
  }

  const controller = new AbortController();
  activeRecoveries.set(taskId, controller);

  const runtimeStore = useConversationRuntimeStore.getState();

  try {
    // 连接恢复 SSE
    const eventSource = new EventSource(`/api/tasks/${taskId}/stream`);

    // 监听中止信号
    controller.signal.addEventListener('abort', () => {
      eventSource.close();
    });

    eventSource.onmessage = (event) => {
      if (event.data === '[DONE]') {
        eventSource.close();
        activeRecoveries.delete(taskId);
        runtimeStore.clearStreamingMessage(conversationId);
        return;
      }

      const data = JSON.parse(event.data);

      if (data.type === 'accumulated') {
        // 累积内容（首次恢复时发送的完整已有内容）
        // 使用固定 ID 更新消息
        runtimeStore.updateStreamingMessage(conversationId, {
          id: assistantMessageId || `streaming-${taskId}`,
          content: data.data.text,
        });
      } else if (data.type === 'content') {
        // 增量内容
        runtimeStore.appendStreamingContent(conversationId, data.data.text);
      } else if (data.type === 'done') {
        // 完成，替换 streaming 消息为真实消息
        runtimeStore.clearStreamingMessage(conversationId);
        if (data.data.assistant_message) {
          // 由于使用了预分配 ID，这里可以直接添加消息而不会闪烁
          runtimeStore.addRealMessage(conversationId, data.data.assistant_message);
          // 或者触发消息列表刷新
          // reloadConversationMessages(conversationId);
        }
        activeRecoveries.delete(taskId);
      } else if (data.type === 'error') {
        runtimeStore.clearStreamingMessage(conversationId);
        runtimeStore.addErrorMessage(conversationId, {
          id: assistantMessageId || `error-${taskId}`,
          conversation_id: conversationId,
          role: 'assistant',
          content: data.data.message,
          created_at: new Date().toISOString(),
          credits_cost: 0,
          is_error: true,
        });
        activeRecoveries.delete(taskId);
      }
    };

    eventSource.onerror = () => {
      eventSource.close();
      activeRecoveries.delete(taskId);
      // 错误时轮询检查任务状态
      pollTaskStatus(taskId, conversationId);
    };
  } catch (error) {
    activeRecoveries.delete(taskId);
    console.error('Failed to resume chat stream:', error);
  }
}
```

### 5.2 消息发送时使用预分配 ID

```typescript
// useMessageCallbacks.tsx
async function handleSendMessage(content: string) {
  // ... 发送消息

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);

    if (data.type === 'task_created') {
      const { task_id: taskId, assistant_message_id: assistantMessageId } = data.data;

      // 保存到 RuntimeStore
      runtimeStore.setChatTaskId(conversationId, taskId);

      // 【关键】使用预分配的 assistant_message_id 创建 streaming 消息
      // 这样当消息完成时，ID 不变，React 不会重新挂载组件
      runtimeStore.addStreamingMessage(conversationId, {
        id: assistantMessageId,  // 使用预分配的固定 ID
        conversation_id: conversationId,
        role: 'assistant',
        content: '',
        created_at: new Date().toISOString(),
        credits_cost: 0,
      });
    }

    if (data.type === 'content') {
      // 增量追加内容
      runtimeStore.appendStreamingContent(conversationId, data.data.text);
    }

    // ... 其他处理
  };
}
```

### 5.3 RuntimeStore 改造

修改 `onRehydrateStorage`，**不立即清理** streaming 消息，等任务恢复后再处理：

```typescript
onRehydrateStorage: () => (state) => {
  if (!state) return;

  // 延迟执行，等待 App 初始化
  setTimeout(async () => {
    // 1. 获取 pending 的 chat 任务
    const pendingTasks = await fetchPendingTasks();
    const chatTaskConversationIds = new Set(
      pendingTasks
        .filter(t => t.type === 'chat')
        .map(t => t.conversation_id)
    );

    // 2. 只清理没有 pending chat 任务的对话的 streaming 消息
    const currentState = useConversationRuntimeStore.getState();
    const newStates = new Map<string, ConversationRuntimeState>();

    currentState.states.forEach((runtimeState, conversationId) => {
      if (chatTaskConversationIds.has(conversationId)) {
        // 有 pending chat 任务，保留 streaming 消息
        newStates.set(conversationId, runtimeState);
      } else {
        // 清理 streaming 消息
        const cleanedMessages = runtimeState.optimisticMessages.filter(
          m => !m.id.startsWith('streaming-')
        );
        newStates.set(conversationId, {
          ...runtimeState,
          optimisticMessages: cleanedMessages,
          streamingMessageId: null,
          isGenerating: false,
        });
      }
    });

    useConversationRuntimeStore.setState({ states: newStates });

    // 3. 恢复 chat 任务
    await restoreAllPendingTasks();
  }, 100);
},
```

### 5.4 多标签页同步模块（v2.2 新增）

新建 `frontend/src/utils/tabSync.ts`：

```typescript
/**
 * 多标签页实时同步管理器
 *
 * 使用 BroadcastChannel API 实现同源标签页间的实时通信
 * 解决：
 * - 标签页 A 完成聊天，标签页 B 不知道
 * - 多标签页重复恢复同一任务
 * - 积分变化不同步
 *
 * 【重要】同源限制：
 * - BroadcastChannel 只能在 **同源（Same-origin）** 标签页间通信
 * - 同源 = 协议 + 域名 + 端口 完全一致
 * - 例：chat.domain.com 和 app.domain.com 是不同源，无法通信
 * - 跨子域名场景：需使用 localStorage fallback 或后端 WebSocket 广播
 * - 当前实现已包含 localStorage fallback，覆盖绝大多数场景
 */

const CHANNEL_NAME = 'everydayai-sync';

export type TabSyncEventType =
  | 'chat_started'      // 聊天开始（用于显示"正在输入"）
  | 'chat_completed'    // 聊天完成（刷新消息列表）
  | 'chat_failed'       // 聊天失败
  | 'task_restored'     // 任务已被恢复（防止重复恢复）
  | 'message_updated'   // 消息更新（重新生成等）
  | 'credits_changed'   // 积分变化
  | 'conversation_deleted'; // 对话删除

interface TabSyncPayload {
  conversationId?: string;
  taskId?: string;
  messageId?: string;
  credits?: number;
  [key: string]: unknown;
}

interface TabSyncEvent {
  type: TabSyncEventType;
  payload: TabSyncPayload;
  timestamp: number;
  tabId: string;
}

type EventCallback = (payload: TabSyncPayload) => void;

class TabSyncManager {
  private channel: BroadcastChannel | null = null;
  private tabId: string;
  private listeners: Map<TabSyncEventType, Set<EventCallback>>;
  private isInitialized: boolean = false;
  private useFallback: boolean = false;  // 是否使用 localStorage fallback
  private readonly STORAGE_KEY = 'everydayai-sync-event';

  constructor() {
    this.tabId = `tab-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    this.listeners = new Map();
    this.init();
  }

  private init() {
    if (typeof window === 'undefined') return;

    // 优先使用 BroadcastChannel
    if ('BroadcastChannel' in window) {
      try {
        this.channel = new BroadcastChannel(CHANNEL_NAME);
        this.channel.onmessage = this.handleMessage.bind(this);
        this.isInitialized = true;
        return;
      } catch (error) {
        console.warn('[TabSync] BroadcastChannel failed, falling back to localStorage:', error);
      }
    }

    // 【降级兜底】使用 StorageEvent（监听 localStorage 变化）
    // 支持率更广，但性能略低于 BroadcastChannel
    try {
      this.useFallback = true;
      window.addEventListener('storage', this.handleStorageEvent.bind(this));
      this.isInitialized = true;
      console.info('[TabSync] Using localStorage fallback');
    } catch (error) {
      console.error('[TabSync] Failed to initialize fallback:', error);
    }
  }

  /**
   * 处理 localStorage 变化事件（fallback 模式）
   */
  private handleStorageEvent(event: StorageEvent) {
    if (event.key !== this.STORAGE_KEY || !event.newValue) return;

    try {
      const data = JSON.parse(event.newValue) as TabSyncEvent;
      // StorageEvent 只会在其他标签页触发，所以不需要检查 tabId
      this.dispatchToListeners(data.type, data.payload);
    } catch (error) {
      console.error('[TabSync] Failed to parse storage event:', error);
    }
  }

  /**
   * 广播事件给其他标签页
   */
  broadcast(type: TabSyncEventType, payload: TabSyncPayload = {}) {
    if (!this.isInitialized) return;

    const event: TabSyncEvent = {
      type,
      payload,
      timestamp: Date.now(),
      tabId: this.tabId,
    };

    try {
      if (this.useFallback) {
        // 【fallback 模式】通过 localStorage 广播
        // 写入后立即删除，触发其他标签页的 storage 事件
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(event));
        localStorage.removeItem(this.STORAGE_KEY);
      } else if (this.channel) {
        // 【正常模式】通过 BroadcastChannel 广播
        this.channel.postMessage(event);
      }
    } catch (error) {
      console.error('[TabSync] Failed to broadcast:', error);
    }
  }

  /**
   * 监听特定事件
   * @returns 取消监听函数
   */
  on(type: TabSyncEventType, callback: EventCallback): () => void {
    if (!this.listeners.has(type)) {
      this.listeners.set(type, new Set());
    }
    this.listeners.get(type)!.add(callback);

    return () => {
      this.listeners.get(type)?.delete(callback);
    };
  }

  /**
   * 监听多个事件
   */
  onMany(
    events: Partial<Record<TabSyncEventType, EventCallback>>
  ): () => void {
    const unsubscribes = Object.entries(events).map(([type, callback]) =>
      this.on(type as TabSyncEventType, callback!)
    );

    return () => unsubscribes.forEach((unsub) => unsub());
  }

  /**
   * 处理来自其他标签页的消息（BroadcastChannel 模式）
   */
  private handleMessage(event: MessageEvent<TabSyncEvent>) {
    const { type, payload, tabId } = event.data;

    // 忽略自己发送的消息
    if (tabId === this.tabId) return;

    this.dispatchToListeners(type, payload);
  }

  /**
   * 分发事件给所有监听者
   */
  private dispatchToListeners(type: TabSyncEventType, payload: TabSyncPayload) {
    const listeners = this.listeners.get(type);
    if (listeners && listeners.size > 0) {
      listeners.forEach((callback) => {
        try {
          callback(payload);
        } catch (error) {
          console.error(`[TabSync] Listener error for ${type}:`, error);
        }
      });
    }
  }

  /**
   * 获取当前标签页 ID
   */
  getTabId(): string {
    return this.tabId;
  }

  /**
   * 销毁（页面卸载时调用）
   */
  destroy() {
    if (this.channel) {
      this.channel.close();
      this.channel = null;
    }
    if (this.useFallback) {
      window.removeEventListener('storage', this.handleStorageEvent.bind(this));
    }
    this.listeners.clear();
    this.isInitialized = false;
  }
}

// 全局单例
export const tabSync = new TabSyncManager();

// 页面卸载时清理
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => tabSync.destroy());
}
```

### 5.5 集成 TabSync 到现有模块

#### 5.5.1 useMessageCallbacks.tsx - 聊天完成时广播

```typescript
import { tabSync } from '@/utils/tabSync';

const handleMessageSent = useCallback(
  (aiMessage?: Message | null) => {
    // ... 原有逻辑 ...

    // 【新增】广播聊天完成事件
    if (aiMessage && !aiMessage.is_error) {
      tabSync.broadcast('chat_completed', {
        conversationId: aiMessage.conversation_id,
        messageId: aiMessage.id,
      });
    } else if (aiMessage?.is_error) {
      tabSync.broadcast('chat_failed', {
        conversationId: aiMessage.conversation_id,
        messageId: aiMessage.id,
      });
    }
  },
  [/* ... */]
);

const handleStreamStart = useCallback(
  (conversationId: string, model: string) => {
    // ... 原有逻辑 ...

    // 【新增】广播聊天开始
    tabSync.broadcast('chat_started', {
      conversationId,
    });
  },
  [/* ... */]
);
```

#### 5.5.2 taskRestoration.ts - 防止重复恢复

```typescript
import { tabSync } from '@/utils/tabSync';

// 被其他标签页恢复的任务 ID 集合
const restoredByOtherTabs = new Set<string>();

// 监听其他标签页的恢复通知
tabSync.on('task_restored', (payload) => {
  if (payload.taskId) {
    restoredByOtherTabs.add(payload.taskId);
  }
});

async function resumeChatStream(
  taskId: string,
  conversationId: string,
  assistantMessageId?: string,
) {
  // 【新增】检查是否已被其他标签页恢复
  if (restoredByOtherTabs.has(taskId)) {
    console.log(`[TaskRestore] Task ${taskId} already restored by another tab`);
    return;
  }

  // 幂等性检查
  if (activeRecoveries.has(taskId)) {
    return;
  }

  // 【新增】广播恢复通知
  tabSync.broadcast('task_restored', {
    taskId,
    conversationId,
  });

  // ... 原有恢复逻辑 ...
}
```

#### 5.5.3 Chat.tsx - 监听同步事件

```typescript
import { tabSync } from '@/utils/tabSync';
import { useChatStore } from '@/stores/useChatStore';

// 在组件内
useEffect(() => {
  const cleanup = tabSync.onMany({
    // 聊天完成：刷新消息列表
    chat_completed: (payload) => {
      if (payload.conversationId) {
        // 如果是当前对话，重新加载消息
        if (payload.conversationId === conversationId) {
          // 触发消息列表刷新
          invalidateMessages(payload.conversationId);
        }
        // 更新侧边栏未读状态
        useChatStore.getState().markConversationUnread(payload.conversationId);
      }
    },

    // 聊天开始：显示"正在输入"状态
    chat_started: (payload) => {
      if (payload.conversationId === conversationId) {
        // 可选：显示其他标签页正在输入的提示
      }
    },

    // 积分变化：刷新用户信息
    credits_changed: () => {
      refreshUser();
    },

    // 对话删除：清理状态
    conversation_deleted: (payload) => {
      if (payload.conversationId === conversationId) {
        // 跳转到其他对话
        navigate('/chat');
      }
    },
  });

  return cleanup;
}, [conversationId, navigate, invalidateMessages, refreshUser]);
```

#### 5.5.4 积分扣除时广播

```typescript
// credit_service.ts 或相关 hook 中
import { tabSync } from '@/utils/tabSync';

// 扣除积分后
async function deductCredits(amount: number) {
  const newBalance = await api.deductCredits(amount);

  // 广播积分变化
  tabSync.broadcast('credits_changed', {
    credits: newBalance,
  });

  return newBalance;
}
```

---

## 六、边界情况处理

| 边界情况 | 处理方式 | 实现位置 |
|---------|---------|---------|
| 刷新时 SSE 正在建立连接 | 任务状态 pending，恢复时重连 `/tasks/{id}/stream` | task.py |
| 刷新时正在流式输出 | 任务状态 running，恢复时继续接收 | task.py |
| 刷新时刚好完成 | 任务状态 completed，直接显示完整消息 | task.py |
| 刷新时出错 | 任务状态 failed，显示错误 | task.py |
| 后端进程重启 | 无活跃队列，前端轮询数据库 | task.py |
| 后台协程超时（>10分钟） | BackgroundTaskWorker 标记失败 | background_task_worker.py |
| **并发竞争（新旧SSE同时获取数据）** | 广播模式 + 多订阅者队列 | ChatStreamManager |
| **协程崩溃（内容不完整）** | finally 块最终一致性保障 | ChatStreamManager |
| **高频刷新（并发恢复）** | activeRecoveries Map + AbortController | taskRestoration.ts |
| **网关超时（60s）** | 心跳间隔缩短至 30s | 全局常量 |
| **消息 ID 闪烁** | 预分配 assistant_message_id | 全流程 |
| 网络断开后重连 | SSE 断开 → onerror → 轮询任务状态 | taskRestoration.ts |
| **多标签页状态不同步** | BroadcastChannel 实时广播 | tabSync.ts |
| **多标签页重复恢复** | restoredByOtherTabs Set + 广播通知 | taskRestoration.ts |
| **多任务并发恢复** | Promise.all 并发启动，显示顺序由 created_at 保证 | taskRestoration.ts |
| **多任务显示顺序** | 前端**严格按 created_at 排序**（非接收顺序），否则 UI 错乱 | MessageList 组件 |
| **部分任务先完成** | 先完成的直接显示内容，其他保持占位符 | taskRestoration.ts |
| **并发恢复渲染错乱** | 任务 A（后发）可能比任务 B（先发）先完成握手，必须按时间戳排序 | MessageList 组件 |
| **流式 usage 丢失** | 确保 adapter 设置 stream_options={"include_usage": True} | ChatStreamManager |
| **SSE 网络波动重连** | 断点续传：last_received_index 参数，避免重复内容 | task.py /stream 端点 |
| **usage 异常中断未返回** | 保底计费：按内容长度估算（1 token ≈ 3 字符） | ChatStreamManager |
| **跨子域名标签页同步** | BroadcastChannel 仅同源；跨域需 WebSocket 或后端广播 | tabSync.ts |

---

## 七、工作量评估

| 模块 | 改动 | 预估 |
|------|------|------|
| 数据库 | 新增字段 | 0.5h |
| 后端 ChatStreamManager | 新建文件 | 2h |
| 后端 message_stream_service | 改造 | 1.5h |
| 后端 task.py | 新增端点 | 1h |
| 后端 background_task_worker | 支持 chat | 0.5h |
| 前端 taskRestoration | 支持 chat | 2h |
| 前端 RuntimeStore | 条件清理 | 1h |
| 前端消息发送 | 保存 task_id | 0.5h |
| **前端 tabSync（v2.2）** | 新建模块 + 集成 | 1.5h |
| 测试 | 各场景测试 | 2h |
| **代码清理** | 旧代码/死代码清理 + 验证 | 1h |
| **总计** | | **13.5h** |

---

## 八、风险评估

| 风险 | 等级 | 缓解措施 |
|------|------|---------|
| 后台协程内存泄漏 | 低 | add_done_callback 自动清理 + 死连接检测 |
| 进程重启丢失任务 | 中 | 数据库保存状态 + 前端轮询兜底 + 最终一致性保障 |
| 数据库写入频率高 | 低 | 500ms 节流，可接受 |
| 积分重复扣除 | 低 | 任务完成时才扣积分，状态原子更新 |
| **并发竞争（新旧连接）** | 低 | 广播模式，每个连接独立队列 |
| **协程异常中断** | 低 | finally 块确保数据库最终一致 |
| **高频刷新并发** | 低 | activeRecoveries 幂等性保护 |
| **网关超时** | 低 | 30s 心跳，远小于常见网关阈值 |
| **UI 闪烁** | 低 | 预分配消息 ID，React Key 不变 |
| **BroadcastChannel 不支持** | 极低 | StorageEvent（localStorage）自动降级，全环境同步 |
| **流式 usage 计费丢失** | 低 | 保底计费：按内容长度估算（1 token ≈ 3 字符） |
| **多标签页重复恢复** | 低 | restoredByOtherTabs Set + 广播通知 |
| **网络波动重连重复内容** | 低 | 断点续传：last_received_index 参数，只发送新消息 |
| **跨子域名无法同步** | 低 | localStorage fallback 已覆盖；跨域需 WebSocket |

---

## 九、实施检查清单

### 9.1 后端改动

- [ ] 数据库：执行 `ALTER TABLE tasks ADD COLUMN accumulated_content TEXT;`
- [ ] 数据库：执行 `ALTER TABLE tasks ADD COLUMN model_id VARCHAR(100);`
- [ ] 数据库：执行 `ALTER TABLE tasks ADD COLUMN total_credits INTEGER DEFAULT 0;`
- [ ] 数据库：执行 `ALTER TABLE tasks ADD COLUMN assistant_message_id UUID;`
- [ ] 新建 `backend/services/chat_stream_manager.py`
- [ ] 改造 `backend/services/message_stream_service.py`
- [ ] 改造 `backend/api/routes/task.py`（新增 `/stream` 和 `/content` 端点）
- [ ] 改造 `backend/services/background_task_worker.py`（支持 chat 类型超时）
- [ ] 改造 `backend/services/message_service.py`（支持指定 message_id）

### 9.2 前端改动

- [ ] 新建 `frontend/src/utils/tabSync.ts`（多标签页同步模块）
- [ ] 改造 `frontend/src/utils/taskRestoration.ts`（支持 chat + 防重复恢复）
- [ ] 改造 `frontend/src/stores/useConversationRuntimeStore.ts`（条件清理）
- [ ] 改造 `frontend/src/hooks/useMessageCallbacks.tsx`（广播事件）
- [ ] 改造 `frontend/src/pages/Chat.tsx`（监听同步事件）

### 9.3 测试场景

**基础功能**：
- [ ] 场景1：发送消息后立即刷新（pending 状态）
- [ ] 场景2：流式输出中刷新（running 状态，有累积内容）
- [ ] 场景3：完成瞬间刷新（completed 状态）
- [ ] 场景4：出错后刷新（failed 状态）
- [ ] 场景5：高频刷新（F5 连按）
- [ ] 场景6：网络断开后重连
- [ ] 场景7：后端重启后恢复（轮询模式）

**多标签页同步（v2.2）**：
- [ ] 场景8：标签页 A 完成聊天 → 标签页 B 自动显示新消息
- [ ] 场景9：标签页 A 恢复任务 → 标签页 B 不重复恢复
- [ ] 场景10：标签页 A 扣除积分 → 标签页 B 余额同步更新
- [ ] 场景11：关闭一个标签页 → 其他标签页不受影响

**多任务并发恢复（v2.2）**：
- [ ] 场景12：多对话各有一个 pending 聊天任务 → 刷新后并发恢复，显示顺序正确
- [ ] 场景13：单对话多个图片任务 pending → 刷新后并发恢复，占位符位置不变
- [ ] 场景14：混合任务（聊天+图片）→ 刷新后各自恢复，互不干扰
- [ ] 场景15：多任务中部分先完成 → 先完成的显示内容，未完成的保持占位符
- [ ] 场景16：恢复过程中新任务完成 → 不影响正在恢复的其他任务

### 9.4 代码清理（实施完成后执行）

**后端清理**：
- [ ] `message_stream_service.py`：检查是否有旧的直接流式处理逻辑被 `ChatStreamManager` 替代，移除死代码
- [ ] `task.py`：检查是否有旧的任务状态轮询端点被新端点替代
- [ ] 检查是否存在重复的 SSE 流式处理实现，统一到 `ChatStreamManager`
- [ ] 移除不再使用的导入语句（import）
- [ ] 检查是否有被注释掉但不再需要的代码块

**前端清理**：
- [ ] `taskRestoration.ts`：移除被新 chat 类型恢复逻辑替代的旧代码
- [ ] `useConversationRuntimeStore.ts`：检查旧的 `onRehydrateStorage` 逻辑是否完全被替换
- [ ] `useMessageCallbacks.tsx`：检查是否有旧的消息完成回调被替代
- [ ] `Chat.tsx`：检查是否有旧的任务状态监听逻辑可以移除
- [ ] 移除不再使用的 hooks、工具函数
- [ ] 检查 `types/` 目录是否有不再使用的类型定义
- [ ] 移除不再使用的导入语句（import）

**通用清理**：
- [ ] 运行 `eslint --fix` 检查未使用的变量和导入
- [ ] 运行 TypeScript 编译检查是否有未使用的类型
- [ ] 搜索 `// TODO`、`// FIXME`、`// HACK` 注释，评估是否可以移除
- [ ] 搜索 `console.log` 调试语句，移除或替换为正式日志
- [ ] 检查是否有被此方案替代的旧文档需要更新或归档

**验证**：
- [ ] 代码清理后重新运行所有测试场景（9.3）
- [ ] 确认清理不影响现有功能
- [ ] 更新 `FUNCTION_INDEX.md`（如有函数增删）
- [ ] 更新 `PROJECT_OVERVIEW.md`（如有文件增删）

---

**确认后开始实施。**
