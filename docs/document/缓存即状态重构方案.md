# 「缓存即状态」重构方案（方案B：保持分离 + 统一入口）

## 一、当前问题

### 1.1 三数据源导致不一致

```
┌─────────────────────────────────────────────────────────────────────┐
│                     当前架构（问题根源）                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   MessageArea.messages ←─ 手动同步 ─→ useChatStore.messageCache    │
│        (组件状态)                         (持久化缓存)               │
│             ↑                                                       │
│        setMessages()              useConversationRuntimeStore       │
│        (多处调用)                      (临时状态)                    │
│                                            ↓                        │
│                              mergeOptimisticMessages()              │
│                                   (合并逻辑)                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
                              ↓
                问题：组件状态与缓存容易不同步
```

### 1.2 具体问题表现

| 问题 | 表现 | 影响 |
|------|------|------|
| 三数据源 | 组件状态 + 持久化缓存 + 临时状态 | 需要手动合并 |
| 组件状态冗余 | `MessageArea.messages` 与缓存重复 | 改一边忘改另一边 |
| 同步分散 | 6+ 处需调用缓存更新函数 | 容易遗漏 |
| 格式转换 | `Message` ↔ `CacheMessage` 互转 | 代码冗余、易出错 |

### 1.3 当前架构的合理之处

| 组件 | 职责 | 保留理由 |
|------|------|---------|
| `useChatStore.messageCache` | 持久化消息（可存 localStorage） | 切换对话秒显 |
| `useConversationRuntimeStore` | 临时消息（temp-/streaming-） | 天然分离，无需过滤持久化 |
| `mergeOptimisticMessages` | 合并两类消息 | 纯函数，测试覆盖完整 |

---

## 二、目标架构

### 2.1 统一读取入口 + 保持存储分离

```
┌─────────────────────────────────────────────────────────────────────┐
│                     目标架构（方案B）                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   useChatStore.messageCache    useConversationRuntimeStore          │
│        (持久化消息)                  (临时消息)                      │
│              ↓                           ↓                          │
│              └─────────┬─────────────────┘                          │
│                        ↓                                            │
│              useUnifiedMessages()                                   │
│              (统一读取 Hook，内置合并逻辑)                           │
│                        ↓                                            │
│                MessageArea 渲染                                     │
│                                                                     │
│   ───────────────────────────────────────────────────────────────   │
│                                                                     │
│                统一写入入口（6 个方法）                              │
│   appendMessage / replaceMessage / removeMessage / setMessages      │
│                        ↓                                            │
│            自动写入对应 Store（持久化 or 临时）                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心原则

1. **统一读取入口**：`useUnifiedMessages()` 封装合并逻辑，组件无需关心数据来源
2. **存储分离保持**：持久化消息和临时消息分开存储，天然支持 localStorage
3. **统一写入入口**：6 个方法自动路由到正确的 Store
4. **删除组件状态**：`MessageArea.messages` 不再需要，直接订阅缓存
5. **格式统一**：删除 `CacheMessage` 类型，统一使用 `Message` 格式

---

## 三、统一操作入口（6 个方法）

### 3.1 方法定义

| 方法名 | 用途 | 写入目标 |
|--------|------|---------|
| `appendMessage` | 追加消息 | 临时消息 → RuntimeStore；持久化消息 → ChatStore |
| `replaceMessage` | 替换消息 | 根据消息 ID 前缀自动路由 |
| `removeMessage` | 删除消息 | 根据消息 ID 前缀自动路由 |
| `setMessages` | 批量设置 | ChatStore（持久化消息） |
| `clearCache` | 清空缓存 | 同时清空两个 Store |
| `setCurrentConversationId` | 切换对话 | 触发 useUnifiedMessages 重新订阅 |

### 3.2 自动路由规则

```typescript
// 根据消息 ID 前缀判断写入目标
function getTargetStore(messageId: string): 'runtime' | 'persistent' {
  if (messageId.startsWith('temp-') ||
      messageId.startsWith('streaming-') ||
      messageId.startsWith('error-')) {
    return 'runtime';  // → useConversationRuntimeStore
  }
  return 'persistent'; // → useChatStore
}
```

---

## 四、改造范围与影响

### 4.1 需要修改的文件（7 个）

| 文件 | 改动内容 | 复杂度 |
|------|---------|--------|
| `stores/useChatStore.ts` | 删除 CacheMessage，新增统一方法，格式统一为 Message | 高 |
| `hooks/useUnifiedMessages.ts` | **新建**，订阅两个 Store + 合并逻辑 | 中 |
| `hooks/useMessageLoader.ts` | 移除格式转换，改用 setMessages | 中 |
| `components/chat/MessageArea.tsx` | 删除 messages 状态，改用 useUnifiedMessages | 中 |
| `hooks/useMessageCallbacks.tsx` | 删除分散的缓存更新，改用统一方法 | 低 |
| `services/messageSender/*.ts` | 部分调用改用统一方法（可选优化） | 低 |
| `utils/regenerate/*.ts` | 调用改用统一方法 | 低 |

### 4.2 需要删除的代码

| 类型 | 具体内容 |
|------|---------|
| 类型定义 | `CacheMessage` 接口（与 `Message` 合并） |
| 转换函数 | `toStoreMessage()`、`convertCacheToApiMessages()` |
| 分散的缓存方法 | `addMessageToCache()`、`replaceMessageInCache()` 等旧方法 |
| 组件状态 | `MessageArea` 中的 `const [messages, setMessages] = useState()` |

### 4.3 保留不变的代码

| 文件 | 保留理由 |
|------|---------|
| `useConversationRuntimeStore.ts` | 职责清晰，管理临时状态 |
| `mergeOptimisticMessages.ts` | 合并逻辑，被 useUnifiedMessages 内部使用 |
| `taskRestoration.ts` | 任务恢复逻辑，调用方式微调 |
| 所有滚动 Hook | 无需改动 |

---

## 五、关键流程说明

### 5.1 消息发送（乐观更新）

```
用户点击发送
    ↓
appendMessage(conversationId, 临时消息)  ← ID: temp-xxx → 写入 RuntimeStore
    ↓
useUnifiedMessages 自动合并 → 组件渲染（显示发送中）
    ↓
后端返回真实消息
    ↓
replaceMessage(conversationId, "temp-xxx", 真实消息)
    ↓
RuntimeStore 移除 temp-xxx，ChatStore 写入真实消息
    ↓
useUnifiedMessages 自动更新 → 组件渲染（显示已发送）
```

### 5.2 流式聊天（增量更新）

```
用户发送消息
    ↓
appendMessage(临时用户消息)     → RuntimeStore
appendMessage(streaming-消息)  → RuntimeStore
    ↓
收到流式内容块
    ↓
replaceMessage(streamingId, { content: 累积内容 })  → RuntimeStore
    ↓                    ↑
    └────────重复────────┘
    ↓
流式结束
    ↓
completeStreaming() 清理 RuntimeStore
setMessages() 写入持久化消息 → ChatStore
```

### 5.3 切换对话

```
用户点击其他对话
    ↓
setCurrentConversationId(newId)
    ↓
useUnifiedMessages 重新订阅：
  - ChatStore.messageCache[newId]
  - RuntimeStore.states[newId]
    ↓
自动合并 → 组件渲染（秒显）
    ↓
（后台）检查 TTL，过期则静默刷新
```

---

## 六、执行步骤

### 步骤 1：重构状态层（useChatStore）

**改动内容**：
- 删除 `CacheMessage` 类型，缓存直接存储 `Message` 格式
- 新增 4 个统一操作方法（appendMessage, replaceMessage, removeMessage, setMessages）
- 保留旧方法（暂不删除，确保兼容）

**验证标准**：
- TypeScript 编译通过
- 现有功能不受影响

---

### 步骤 2：新增统一读取 Hook（useUnifiedMessages）

**改动内容**：
- 新建 `hooks/useUnifiedMessages.ts`
- 订阅 `useChatStore.messageCache` + `useConversationRuntimeStore.states`
- 内部调用 `mergeOptimisticMessages()` 合并
- 返回合并后的消息列表

**代码示例**：
```typescript
export function useUnifiedMessages(conversationId: string | null): Message[] {
  // 订阅持久化消息
  const persistedMessages = useChatStore(
    (state) => conversationId ? state.messageCache.get(conversationId)?.messages : []
  );

  // 订阅运行时状态
  const runtimeState = useConversationRuntimeStore(
    (state) => conversationId ? state.states.get(conversationId) : undefined
  );

  // 合并（内部使用 mergeOptimisticMessages）
  return useMemo(() =>
    mergeOptimisticMessages(persistedMessages ?? [], runtimeState),
    [persistedMessages, runtimeState]
  );
}
```

**验证标准**：
- Hook 能正确返回合并后的消息
- 切换对话时数据正确切换

---

### 步骤 3：改造数据加载层（useMessageLoader）

**改动内容**：
- 移除 `toStoreMessage()` 格式转换
- 改用 `setMessages()` 直接写入 Message 格式
- 移除返回的 `getCachedMessages`、`updateCachedMessages`

**验证标准**：
- 加载对话时缓存正确写入
- TTL 过期时能静默刷新

---

### 步骤 4：改造组件层（MessageArea）

**改动内容**：
- 删除 `const [messages, setMessages] = useState()`
- 删除 `useMessageLoader` 返回的 `messages`
- 改用 `const messages = useUnifiedMessages(conversationId)`
- 删除手动调用 `mergeOptimisticMessages` 的 useMemo

**验证标准**：
- 消息正常渲染
- 切换对话秒显
- 乐观更新正常显示
- 流式消息正常显示

---

### 步骤 5：改造业务层回调（useMessageCallbacks）

**改动内容**：
- 删除分散的缓存更新调用
- 保持对 RuntimeStore 的调用（乐观更新仍然写入 RuntimeStore）
- 流式完成后调用 `setMessages` 写入持久化缓存

**验证标准**：
- 发送消息后缓存实时更新
- 流式完成后缓存正确写入
- 切换对话看到最新消息

---

### 步骤 6：清理冗余代码

**改动内容**：
- 删除 `CacheMessage` 类型定义
- 删除 `toStoreMessage()`、`convertCacheToApiMessages()` 函数
- 删除旧的分散缓存方法（确认无调用后）
- 清理未使用的导入

**验证标准**：
- 所有功能正常
- 无 TypeScript 报错
- 无未使用的导入警告

---

## 七、风险控制

| 措施 | 说明 |
|------|------|
| **增量验证** | 每完成一步立即测试，不等全部完成 |
| **兜底机制** | 30 秒 TTL，缓存异常时自动拉取后端数据 |
| **回滚预案** | Git 提交备份，异常可快速回滚 |
| **兼容过渡** | 步骤 1 保留旧方法，确保过渡期兼容 |
| **保持分离** | 不合并两个 Store，降低改动风险 |

---

## 八、收益总结

| 维度 | 改造前 | 改造后 |
|------|--------|--------|
| 数据源 | 三数据源（组件 + 持久化缓存 + 临时状态） | 两数据源 + 统一读取入口 |
| 组件状态 | MessageArea 维护 messages 状态 | 删除，直接订阅缓存 |
| 合并逻辑 | 组件内手动调用 | 封装在 useUnifiedMessages 内 |
| 格式转换 | 2 个转换函数 | 无转换，格式统一 |
| 改动文件数 | - | 7 个（vs 方案A的12个） |
| 风险等级 | - | 低（保持存储分离） |

---

## 九、方案对比（为什么选择方案B）

| 维度 | 方案A（完全统一） | 方案B（保持分离） ✅ |
|------|-------------------|---------------------|
| 数据源 | 1 个（useChatStore） | 2 个 + 统一读取入口 |
| 修改文件数 | 12 个 | 7 个 |
| 删除文件数 | 2 个 | 0 个 |
| 持久化处理 | 需过滤临时消息 | 天然分离，无需处理 |
| 职责清晰度 | 混合（消息 + 流式 + UI） | 清晰（持久化 vs 临时） |
| 风险等级 | 高 | 低 |
| 核心收益 | 统一 | 删除组件状态 + 格式统一 |

**选择方案B的理由**：
1. 改动范围可控（7 文件 vs 12 文件）
2. 不需要处理持久化过滤逻辑
3. 保持现有架构的职责清晰度
4. 同样解决了核心问题（组件状态冗余 + 格式不统一）
